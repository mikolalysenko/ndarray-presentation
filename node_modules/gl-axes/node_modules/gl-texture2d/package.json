{
  "name": "gl-texture2d",
  "version": "0.1.11",
  "description": "WebGL texture wrapper",
  "main": "texture.js",
  "directories": {
    "example": "example"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/gl-texture2d.git"
  },
  "keywords": [
    "webgl",
    "texture",
    "wrap",
    "ndarray"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "0d66ce40f2e25b0715689758e9a659f6544f9f3e",
  "bugs": {
    "url": "https://github.com/mikolalysenko/gl-texture2d/issues"
  },
  "devDependencies": {
    "gl-now": "0.0.0",
    "gl-shader": "0.0.0",
    "lena": "~1.0.0"
  },
  "dependencies": {
    "webglew": "^0.0.0",
    "ndarray": "^1.0.10",
    "typedarray-pool": "^0.1.1",
    "ndarray-ops": "^1.1.0",
    "bit-twiddle": "^0.0.2",
    "cwise-compiler": "^0.1.0"
  },
  "readme": "gl-texture2d\n============\n[ndarray](https://github.com/mikolalysenko/ndarray) compatible wrapper for [WebGLTexture objects](http://www.khronos.org/registry/webgl/specs/latest/)\n\n# Example\n\n[Try it in your browser right now](http://mikolalysenko.github.io/gl-texture2d/)\n\n```javascript\nvar shell = require(\"gl-now\")()\nvar createShader = require(\"gl-shader\")\nvar createTexture = require(\"gl-texture2d\")\n\nvar lena = require(\"lena\")\n\nshell.on(\"gl-init\", function() {\n  var gl = shell.gl\n  \n  var texture = createTexture(gl, lena)\n  \n  var shader = createShader(gl, \"\\\n    attribute vec2 position;\\\n    varying vec2 texCoord;\\\n    void main() {\\\n      gl_Position = vec4(position, 0, 1);\\\n      texCoord = vec2(0.5,-0.5) * (position + 1.0);\\\n    }\", \"\\\n    precision highp float;\\\n    uniform sampler2D texture;\\\n    varying vec2 texCoord;\\\n    void main() {\\\n      gl_FragColor = texture2D(texture, texCoord);\\\n    }\")\n  \n  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n    -1, -1,\n     4, -1,\n    -1,  4\n  ]), gl.STATIC_DRAW)\n  \n  texture.bind(0)\n  shader.bind()\n  shader.uniforms.texture = 0\n  shader.attributes.position.pointer()\n  shader.attributes.position.enable()\n})\n\nshell.on(\"gl-render\", function() {\n  var gl = shell.gl\n  gl.drawArrays(gl.TRIANGLES, 0, 3)\n})\n```\n\nHere is what it should look like:\n\n<img src=\"https://raw.github.com/mikolalysenko/gl-texture2d/master/screenshot.png\">\n\n# Install\n\n    npm install gl-texture2d\n\n# API\n\n```javascript\nvar createTexture = require(\"gl-texture2d\")\n```\n\n## Constructor\nThere are three basic usage patterns for `createTexture`:\n\n### `var tex = createTexture(gl, width, height[, format, type])`\nCreates an unitialized texture with the given dimensions and format\n\n* `width` is the width of texture\n* `height` is the height of the texture\n* `format` (optional) is the format of the texture (default `gl.RGBA`)\n* `type` is the type of texture (default `gl.UNSIGNED_BYTE`)\n\n### `var tex = createTexture(gl, dom_element[, format, type])`\nCreates a texture from the given data source.  Where `dom_element` is one of the following items:\n\n* An `ImageData` object\n* An `HTMLCanvas` object\n* An `HTMLImage` object\n* An `HTMLVideo` object\n\nAnd `format` is an OpenGL data format or defaults to `gl.RGBA` and `type` is the storage type which defaults to `gl.UNSIGNED_BYTE`\n\n### `var tex = createTexture(gl, array)`\nCreates a texture from an [ndarray](https://github.com/mikolalysenko/ndarray).  The rules for selecting the format and type depend on the shape of the ndarray.  The type of the texture is inferred according to the following rules.  Let:\n\n* `dtype = ndarray.dtype(array)`\n* `shape = array.shape`\n\nThen the rules for `type` and `format` are defined according to the following table:\n\n| `dtype`      | `shape`    | `format`        | `type`                 |\n| ------------ |:----------:|:---------------:|:----------------------:|\n| `float*`     | [m,n]      | LUMINANCE       | FLOAT                  |\n| `float*`     | [m,n,1]    | ALPHA           | FLOAT                  |\n| `float*`     | [m,n,2]    | LUMINANCE_ALPHA | FLOAT                  |\n| `float*`     | [m,n,3]    | RGB             | FLOAT                  |\n| `float*`     | [m,n,4]    | RGBA            | FLOAT                  |\n| `(u)int*`    | [m,n]      | LUMINANCE       | UNSIGNED_BYTE          |\n| `(u)int*`    | [m,n,1]    | ALPHA           | UNSIGNED_BYTE          |\n| `(u)int*`    | [m,n,2]    | LUMINANCE_ALPHA | UNSIGNED_BYTE          |\n| `(u)int*`    | [m,n,3]    | RGB             | UNSIGNED_BYTE          |\n| `(u)int*`    | [m,n,4]    | RGBA            | UNSIGNED_BYTE          |\n\nOther combinations of shape and dtype are invalid and throw an error.\n\n## Texture Methods\n\n### `tex.bind([tex_unit])`\nBinds the texture for use.  Basically a short cut for:\n\n```javascript\ngl.activeTexture(gl.TEXTURE0 + tex_unit)\ngl.bindTexture(gl.TEXTURE_2D, this.handle)\n```\nIf `tex_unit` is not specified then the active texture is not changed.\n\n**Returns** The texture unit the texture is bound to.\n\n### `tex.dispose()``\nDestroys the texture object and releases all of its resources.  Under the hood this is equivalent to:\n\n```javascript\ngl.deleteTexture(this.handle)\n```\n\n### `tex.setPixels(data[, x_off, y_off, mip_level])`\nUnpacks `data` into a subregion of the texture.  As before in the constructor `data` can be either an `ndarray`, `HTMLCanvas`, `HTMLImage` or `HTMLVideo` object.  If `data` is an ndarray it must have a compatible format with the initial array layout.\n\n* `x_off` is the x offset to write from. (default `0`)\n* `y_off` is the y offset to write from. (default `0`)\n* `mip_level` is the mip level to write to. (default `0`)\n\nIf `data` is an `ndarray` the same rules as in the constructor are followed for converting the type of the buffer.\n\n### `tex.generateMipmap()`\nGenerates mipmaps for the texture.  This will fail if the texture dimensions are not a power of two.\n\n## Texture Properties\n\n#### `tex.shape`\nAn array representing the `[height, width]` of the texture\n\n#### `tex.wrapS`\nS wrap around behavior.  Used to set/get `gl.TEXTURE_WRAP_S`.  Defaults to gl.CLAMP_TO_EDGE\n\n#### `tex.wrapT`\nT wrap around behavior.  Used to set/get `gl.TEXTURE_WRAP_T`. Defaults to gl.CLAMP_TO_EDGE\n\n#### `tex.magFilter`\nMagnification filter.  Used to set/get `gl.TEXTURE_MAG_FILTER`. Defaults to gl.NEAREST\n\n#### `tex.minFilter`\nMinification filter. Used to set/get `gl.TEXTURE_MIN_FILTER`. Defaults to gl.NEAREST\n\n#### `tex.mipSamples`\nThe number of anisotropic filtering samples to use.  This requires `EXT_texture_filter_anisotropic` to have any effect.  High values will improve mipmap quality, but decrease performance.\n\n## Internals\n\n#### `tex.gl`\nA reference to the WebGL context of the texture.\n\n#### `tex.handle`\nA handle to the underlying texture object.\n\n#### `tex.format`\nThe internal format of the texture.\n\n#### `tex.type`\nThe internal data type of the texture.\n\n\n# Credits\n(c) 2013 Mikola Lysenko. MIT License",
  "homepage": "https://github.com/mikolalysenko/gl-texture2d",
  "_id": "gl-texture2d@0.1.11",
  "_from": "gl-texture2d@^0.1.11"
}
