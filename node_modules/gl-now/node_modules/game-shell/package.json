{
  "name": "game-shell",
  "version": "1.0.0",
  "description": "Ready-to-go game shell",
  "main": "shell.js",
  "directories": {
    "example": "example"
  },
  "dependencies": {
    "domready": "~0.2.11",
    "invert-hash": "~0.0.0",
    "iota-array": "~0.0.0",
    "uniq": "~0.0.2",
    "vkey": "~0.0.2",
    "binary-search-bounds": "~0.3.1"
  },
  "devDependencies": {},
  "scripts": {
    "test": "browservefy example/index.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/game-shell.git"
  },
  "keywords": [
    "game",
    "shell",
    "canvas",
    "webgl",
    "input",
    "binding",
    "keyboard",
    "mouse",
    "event",
    "request",
    "animation",
    "frame",
    "raf",
    "tick",
    "clock",
    "engine"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "aeda32c1ed595c725ef36d2ddd1c41d54a9b895c",
  "readme": "game-shell\n==========\nA generic shell for creating interactive demos/games in JavaScript.  This gives you the following features:\n\n* A `init` event which is triggered on page load\n* A `render` event which is called every frame or as needed\n* A frame rate independent `tick` event that is called at uniform intervals\n* A `resize` event that gets called whenever the game changes size\n* Virtual key bindings\n* A polling interface for key and mouse states\n* Wrappers for fullscreen, pointer lock and precision timing APIs\n\n# Example\n\n```javascript\nvar shell = require(\"game-shell\")()\n\nvar context\n  , player_x = 250\n  , player_y = 250\n\n//Bind keyboard commands\nshell.bind(\"move-left\", \"left\", \"A\")\nshell.bind(\"move-right\", \"right\", \"D\")\nshell.bind(\"move-up\", \"up\", \"W\")\nshell.bind(\"move-down\", \"down\", \"S\")\n\n//Fired when document is loaded\nshell.on(\"init\", function() {\n  var canvas = document.createElement(\"canvas\")\n  canvas.width = 500\n  canvas.height = 500\n  shell.element.appendChild(canvas)\n  context = canvas.getContext(\"2d\")\n})\n\n//Fired once per game tick\nshell.on(\"tick\", function() {\n  console.log(\"Tick\")\n  if(shell.wasDown(\"move-left\")) {\n    player_x -= 1\n  }\n  if(shell.wasDown(\"move-right\")) {\n    player_x += 1\n  }\n  if(shell.wasDown(\"move-up\")) {\n    player_y -= 1\n  }\n  if(shell.wasDown(\"move-down\")) {\n    player_y += 1\n  }\n})\n\n//Render a frame\nshell.on(\"render\", function(frame_time) {\n  context.fillStyle = \"#000\"\n  context.fillRect(0, 0, 500, 500)\n  \n  context.fillStyle = \"#f00\"\n  context.fillRect(player_x-10, player_y-10, 20, 20)\n})\n```\n[Try this example in your browser right now!](http://mikolalysenko.github.io/game-shell/)\n\n# Install\n\n    npm install game-shell\n\n# API\n\n## Constructor\n\n### `var shell = require(\"game-shell\")([options])`\n\n* `element` - The DOM element to attach all input listeners to.  Can be either an element, a string representing the id, the CSS class or the element class. (defaults to creating a new element and adding to `document.body`)\n* `tickRate` - The time between ticks in milliseconds (default `33`)\n* `frameSkip` - The maximum alloted time between render updates (default `(tickRate+5)*5`)\n* `bindings` - A default set of key bindings\n* `fullscreen` - A flag which if set attempts to put the game in fullscreen mode\n* `pointerLock` - A flag which if set attempts to active pointer pointer lock (default true  for fullscreen, false otherwise)\n* `sticky` - If set to true, then keep trying to grab fullscreen/pointerLock even if user escapes out\n\n## Events\n\n### `init`\nThis event is fired once the document is loaded and it is safe to access the DOM\n\n### `tick`\nCalled each time the game state needs to be updated.  This is not tied to rendering rate.\n\n### `render ([frame_time])`\nCalled when a frame is redrawn.  The optional parameter `frame_time` is a floating point value between `0` and `1` which measures the fractional amount of frames since the last time the game was ticked.  This can be used to create smoother sub-tick animations if desired.\n\n### `resize([w,h])`\nTriggered whenever the element is resized.  `w` is the new width and `h` is the new height of the element.\n\n## Input\n\n### `wasDown(key)`\nReturns true if the key was ever down during the last tick\n\n### `wasUp(key)`\nReturns true if the key was ever up during the last tick\n\n### `press(key)`\nReturns the number of times a key was pressed since last tick\n\n### `release(key)`\nReturns the number of times a key was released since last tick\n\n### `mouseX`, `mouseY`\nThe x/y coordinates of the mouse relative to the element\n\n### `prevMouseX`, `prevMouseY`\nThe x/y coordinates of the mouse on the previous frame.\n\n### `scroll`\nThe amount the window scrolled due to mousewheel movement.  Represented as 3D array, the units are in pixels.\n\n### `bind(virtual_key, physical_keys, ...)`\nBinds a virtual key to one or more physical keys.  This is added to all previous bindings.\n\n### `unbind(virtual_key)`\nUnbinds a virtual key, removing it from the bindings object\n\n### `keyNames`\nA list of all physical key names which are supported\n\n### `bindings`\nAn object which lists all of the physical keys which each virtual key is bound to.  This can be used to save key state\n\n## Timing\n\n### `frameSkip`\nSets the threshold for time to skip the game\n\n### `tickCount`\nA count of the total number of ticks\n\n### `frameCount`\nA count of the total number of frames rendered\n\n### `tickTime`\nA weighted average of the time required to update the game state in milliseconds\n\n### `frameTime`\nA weighted average of the time required per frame in milliseconds\n\n### `startTime`\nThe time the simulation was started at in milliseconds\n\n## Miscellaneous\n\n### `paused`\nIf set, then the game is paused and no tick events are fired.  You can pause the game by assigning to this variable:\n\n```javascript\n//Pause the game\nshell.paused = true\n\n//Unpause the game\nshell.paused = false\n```\n\n### `fullscreen`\nSets or tests whether the game is fullscreen\n\n### `stickyFullscreen`\nIf set try to continuously reacquire fullscreen\n\n### `pointerLock`\nSets or tests whether the game has a pointer lock\n\n### `stickyPointerLock`\nIf set try to continuously reacquire pointer lock\n\n### `element`\nThe DOM element associated with the shell\n\n### `width`\nThe width of the element contained by the shell\n\n### `height`\nThe height of the element contained by the shell\n\n# Credits\n(c) 2013 Mikola Lysenko. MIT License",
  "bugs": {
    "url": "https://github.com/mikolalysenko/game-shell/issues"
  },
  "homepage": "https://github.com/mikolalysenko/game-shell",
  "_id": "game-shell@1.0.0",
  "_from": "game-shell@~1.0.0"
}
