{
  "name": "ndarray",
  "version": "0.2.4",
  "description": "Multidimensional Arrays",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "tap": "~0.4.0"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/ndarray.git"
  },
  "keywords": [
    "ndarray",
    "array",
    "multi",
    "multidimensional",
    "dimension",
    "higher",
    "image",
    "volume",
    "webgl",
    "tensor",
    "matrix",
    "linear",
    "algebra",
    "science",
    "numerical",
    "computing",
    "stride",
    "shape"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "a85785ca7a7e12c3fc29671a4f7c214bebc4ddc7",
  "readme": "ndarray\n=======\nMultidimensional arrays for JavaScript.\n\nBasic Usage\n===========\nFirst, install the library using npm:\n\n```sh\nnpm install ndarray\n```\n\nThen you can use it in your projects as follows:\n\n```javascript\nvar ndarray = require(\"ndarray\")\n```\n    \nTo create an array full of zeros, you just call `ndarray.zeros()`.  For example, this makes a 128x128 array of floats:\n\n```javascript\nvar img = ndarray.zeros([128, 128], \"float32\")\n```\n\nYou can also wrap existing typed arrays in ndarrays.  For example, here is how you can turn a length 4 typed array into an nd-array:\n\n```javascript\nvar mat = ndarray(new Float64Array([1, 0, 0, 1]), [2,2])\n```\n\nOnce you have an nd-array you can access elements using `.set` and `.get`.  For example, here is some code to apply a box filter to an image using these routines:\n\n```javascript\nvar A = ndarray.zeros([128,128])\nvar B = ndarray.zeros([128,128])\n\nfor(var i=1; i<127; ++i) {\n  for(var j=1; j<127; ++j) {\n    var s = 0;\n    for(var dx=-1; dx<=1; ++dx) {\n      for(var dy=-1; dy<=1; ++dy) {\n        s += A.get(i+dx, j+dy)\n      }\n    }\n    B.set(i,j,s/9.0)\n  }\n}\n```\n\nYou can also pull out views of ndarrays without copying the underlying elements.  Here is an example showing how to update part of a subarray:\n\n```javascript\nvar x = ndarray.zeros([5, 5])\nvar y = x.hi(4,4).lo(1,1)\n\nfor(var i=0; i<y.shape[0]; ++i) {\n  for(var j=0; j<y.shape[1]; ++j) {\n    y.set(i,j,1)\n  }\n}\n\n//Now:\n//    x = 0 0 0 0 0\n//        0 1 1 1 0\n//        0 1 1 1 0\n//        0 1 1 1 0\n//        0 0 0 0 0\n```\n\nBasic Functions\n===============\n### `ndarray(typed_array[, shape, stride, offset])`\n\nCreates an n-dimensional array view wrapping the specified typed array.\n\n* `typed_array` is a typed array\n* `shape` is the shape of the view (Default: `[typed_array].length`)\n* `stride` is the resulting stride of the new array.  (Default: row major)\n* `offset` is the offset to start the view (Default: `0`)\n\nReturns an n-dimensional array view of the buffer\n\n### `ndarray.dtype(array)`\n\nReturns the data type of the underlying array.  The result is one of the following strings: `\"int8\"`, `\"int16\"`, `\"int32\"`, `\"uint8\"`, `\"uint16\"`, `\"uint32\"`, `\"float32\"`, `\"float64\"` or `null` (the last one occuring only if the array is invalid).  These correspond to the various [typed arrays](http://www.khronos.org/registry/typedarray/specs/latest/).\n\n### `ndarray.zeros(shape[, dtype, order])`\n\nCreates an array filled with zeros.\n\n* `shape` is the shape of the array to create\n* `dtype` is the datatype of the array to create.  Must be one of the strings specified in the above list. (Default: `\"float64\"`)\n* `order` is the order of the components of the array, encoded as a permutation.  (Default: row-major)\n\nReturns a view of a newly allocated array.\n\n\n### `ndarray.size(array)`\nComputes the size of the flattened ndarray\n\n* `array` is a view of an nd-array\n\n**Returns** The number of elements in the array.\n\n### `ndarray.order(array)`\n\nReturns the order of the array represented as a permutation.\n\n* `array` is a view of an nd-array\n\nThe result gives you an ordered list, representing the strides sorted in ascending order.  For example, if an array in C/row-major order, then:\n\n```javascript\nndarray.order(array) == [ array.shape.length-1, array.shape.length-2 ..., 1, 0 ]\n```\n\nWhile if the array is in FORTRAN/column-major order, you get:\n\n```javascript\nndarray.order(array) == [ 0, 1, ...,  array.shape.length-2, array.shape.length-1 ]\n```\n\n### `ndarray.ctor(data, shape, stride, offset)`\nDirectly constructs a new ndarray without any checking (not recommended, unless you know what you are doing).\n\n* `data` the underlying typed array\n* `shape` shape of typed array\n* `stride` striding of typed array\n* `offset` offset of typed array\n\n**Returns** A new typed array\n\n### `ndarray.stride(shape[, order])`\nComputes the stride for a packed ndarray with the given order.  If the order is not specified row major order is assumed.\n\n* `shape` the shape if the array\n* `order` the order of the stride\n\n**Returns** The stride of the array\n\nViews\n=====\nThe central concept in `ndarray` is the idea of a view.  The way these work is very similar to [SciPy's array slices](http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html).  Views are references to ranges within typed arrays.  To better understand what this means, let's first look at the properties of the view object.  It has exactly 4 variables:\n\n* `array.data` - The underlying typed array of the multidimensional array\n* `array.shape` - The shape of the typed array, encodes dimensions\n* `array.stride` - The layout of the typed array in memory\n* `array.offset` - The starting offset of the array in memory\n\nKeeping a separate stride means that we can use the same data structure to support both [row major and column major storage](http://en.wikipedia.org/wiki/Row-major_order)\n\n\n## Element Access\nTo access elements of the array, you can use the `set/get` methods:\n\n### `array.get(i,j,...)`\nRetrieves element `i,j,...` from the array.  In psuedocode, this is implemented as follows:\n\n```javascript\nfunction get(i,j, ...) {\n  return this.data[this.offset + this.stride[0] * i + this.stride[1] * j + ... ];\n}\n```\n\n### `array.set(i,j ..., v)`\nSets element `i,j,...` to `v`. Again, in psuedocode this works like this:\n\n```javascript\nfunction set(i,j, ..., v) {\n  return this.data[this.offset + this.stride[0] * i + this.stride[1] * j + ... ] = v;\n}\n```\n\n## Slicing\nGiven a view, we can change the indexing by shifting, truncating or permuting the strides.  This lets us perform operations like array reversals or matrix transpose in **constant time** (well, technically `O(shape.length)`, but since shape.length is typically less than 4, it might as well be).  To make life simpler, the following interfaces are exposed:\n\n### `array.lo(i,j,k,...)`\nThis creates a shifted view of the array.  Think of it as taking the upper left corner of the image and dragging it inward by an amount equal to `(i,j,k...)`.\n\n### `array.hi(i,j,k,...)`\nThis does the dual of `array.lo()`.  Instead of shifting from the top-left, it truncates from the bottom-right of the array, returning a smaller array object.   Using `hi` and `lo` in combination lets you select ranges in the middle of an array.\n\n**Note:**  `hi` and `lo` do not commute.   In general:\n\n```javascript\na.hi(3,3).lo(3,3)  !=  a.lo(3,3).hi(3,3)\n```\n\n### `array.step(i,j,k...)`\nChanges the stride length by rescaling.  Negative indices flip axes.  For example, here is how you create a reversed view of a 1D array:\n\n```javascript\nvar reversed = a.step(-1)\n```\n\nYou can also change the step size to be greater than 1 if you like, letting you skip entries of a list.  For example, here is how to split an array into even and odd components:\n\n```javascript\nvar evens = a.step(2)\nvar odds = a.lo(1).step(2)\n```\n\n### `array.transpose(p0, p1, ...)`\nFinally, for higher dimensional arrays you can transpose the indices in place.  This has the effect of permuting the shape and stride values.  For example, in a 2D array you can calculate the matrix transpose by:\n\n```javascript\nM.transpose(1, 0)\n```\n\nOr if you have a 3D volume image, you can shift the axes using more generic transformations:\n\n```javascript\nvolume.transpose(2, 0, 1)\n```\n\n### `array.pick(p0, p1, ...)`\nYou can also pull out a subarray from an ndarray by fixing a particular axis.  The way this works is you specify the direction you are picking by giving a list of values.  For example, if you have an image stored as an nxmx3 array you can pull out the channel as follows:\n\n```javascript\nvar red   = image.pick(-1, -1, 0)\nvar green = image.pick(-1, -1, 1)\nvar blue  = image.pick(-1, -1, 2)\n```\n\n\n## Miscellaneous\nFinally, there are a few odd ball methods for debugging arrays:\n\n### `array.toString()`\nMakes a human readable stringified version of the contents of the view.\n\n\nFAQ\n===\n\n## What are the goals of this library?\n\nTo expose a simple, low level interface for working with contiguous blocks of memory.  The intended applications for this code are:\n\n* WebGL interoperability\n* Image processing\n* Volume graphics\n* Mesh processing\n* Scientific computing (ie finite difference based PDE solvers)\n\nThis is **not** a linear algebra library, and does not implement things like component-wise arithmetic or tensor operations, though you can use it to do that stuff if you like.  If you are interested in those things, check out the following packages which are built on top of ndarray:\n\n* [cwise](http://github.com/mikolalysenko/cwise)\n* [ndarray-ops](http://github.com/mikolalysenko/ndarray-ops)\n\n## Why use this library instead of manual management of flat typed arrays?\n\nWhile you can recreate the functionality of this library using typed arrays and manual index arithmetic, in practice doing that is very tedious and error prone.  It also means that you need to pass around extra semantic information, like the shape of the multidimensional array and it's striding.  Using a view, you can get nearly the same performance as a flat typed array, while still maintaining all of the relevant semantic information.\n\n## Why use this library instead of numeric.js?\n\nNumeric.js is a fantastic library, and has many useful features for numerical computing.  If you are working with sparse linear systems, or need to solve a linear/quadratic programming problem it should be your go-to library.  However, numeric.js uses arrays-of-native-arrays to encode multidimensional arrays, which makes it suboptimal for image processing and solving PDEs on grids. The reasons for this are as follows:\n\n* Native arrays are much slower than typed arrays. [Proof](https://github.com/mikolalysenko/ndarray-experiments)\n* Allocating an array of native-arrays induces an overhead of O(n^{d-1}) extra independent JavaScript objects.  Not only does this greatly increase the amount of memory consumed, but it also prevents them from scaling with block size (leading to cache performance problems).\n* Slicing arrays-of-arrays is an O(n) operation, while resizing a view is only O(1) and can be done without allocating any intermediate objects.\n* Arrays-of-arrays can not be directly uploaded to WebGL, and instead require a costly \"unboxing\" step to convert them into a typed array.\n\n## What optimizations does this library use?\n\n* Typed array storage\n* In place slicing (ie `subarray()` like semantics)\n* Optimized classes for low dimensional views (shape.length <= 4)\n* Cache oblivious view assignment and copying (implemented in `cwise`)\n\n## Does this library do any error checking?\n\nThe constructors are validated, but slicing and element access are not, since this would be prohibitively slow.  If you write past the bounds of the array, you will corrupt the contents of the underlying array object.\n\nCredits\n=======\n(c) 2013 Mikola Lysenko. MIT License",
  "bugs": {
    "url": "https://github.com/mikolalysenko/ndarray/issues"
  },
  "homepage": "https://github.com/mikolalysenko/ndarray",
  "_id": "ndarray@0.2.4",
  "_from": "ndarray@~0.2.4"
}
