{
  "name": "cwise",
  "version": "0.3.4",
  "description": "Component-wise map/reduce for ndarrays",
  "main": "cwise.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "cwise-parser": "~0.0.1",
    "cwise-compiler": "~0.0.0"
  },
  "devDependencies": {
    "ndarray": "~1.0.1",
    "tap": "~0.4.0"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/cwise.git"
  },
  "keywords": [
    "ndarray",
    "component",
    "scientific",
    "computing",
    "volume",
    "image",
    "array",
    "typed",
    "array",
    "scalar",
    "math",
    "linear",
    "algebra"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "gitHead": "1dd03e72f1b0fbec4186e497b3956d87aec6fc15",
  "readmeFilename": "README.md",
  "readme": "cwise\n=====\nThis library can be used to generate cache efficient map/reduce operations for [ndarrays](http://github.com/mikolalysenko/ndarray).\n\nUsage\n=====\nFirst, install using npm:\n\n    npm install cwise\n    \nThen you can create an ndarray operation as follows:\n\n```javascript\n//Import libraries\nvar cwise = require(\"cwise\")\n  , ndarray = require(\"ndarray\")\n\n//Create operation\nvar addeq = cwise({\n    args: [\"array\", \"array\"],\n    body: function(a, b) {\n      a += b\n    }\n  })\n\n//Create two 2D arrays\nvar X = ndarray(new Float32Array(128*128), [128,128])\nvar Y = ndarray(new Float32Array(128*128), [128,128])\n\n//Add them together\naddeq(X, Y)\n```\n\nFormally, you can think of `addeq(X,Y)` as being something like the following for-loop, except optimized with respect to the dimension and order of X and Y:\n\n```javascript\nfor(var i=0; i<X.shape[0]; ++i) {\n  for(var j=0; j<X.shape[1]; ++j) {\n    X.set(i,j, X.get(i,j) + Y.get(i,j))\n  }\n}\n```\n\n\n`require(\"cwise\")(user_args)`\n-----------------------------\nTo use the library, you pass it an object with the following fields:\n\n* `args`: (Required) An array describing the type of the arguments passed to the body.  These may be one of the following:\n    + `\"array\"`: An `ndarray`-type argument\n    + `\"scalar\"`: A globally broadcasted scalar argument\n    + `\"index\"`: (Hidden) An array representing the current index of the element being processed.  Initially [0,0,...] in the pre block and set to some undefined value in the post block.\n    + `\"shape\"`: (Hidden) An array representing the shape of the arrays being processed\n* `pre`: A function to be executed before starting the loop\n* `body`: (Required) A function that gets applied to each element of the input arrays\n* `post`: Executed when loop completes\n* `printCode`: If this flag is set, then log all generated code\n* `blockSize`: The size of a block (default 32)\n* `funcName`: The name to give to the generated procedure for debugging/profiling purposes.  (Default is `body.name||\"cwise\"`)\n\nThe result is a procedure that you can call which executes these methods along the following lines:\n\n```javascript\nfunction(a0, a1, ...) {\n  pre()\n  for(var i=0; i<a0.shape[0]; ++i) {\n    for(var j=0; j<a0.shape[1]; ++j) {\n      ...\n      \n          body(a0[i,j,...], a1[i,j,...], ... )\n    }\n  }\n  post()\n}\n```\n\n### Notes\n* To pass variables between the pre/body/post, use `this.*`\n* The order in which variables get visited depends on the stride ordering if the input arrays.  In general it is not safe to assume that elements get visited (co)lexicographically.\n* If no return statement is specified, the first ndarray argument is returned\n* All input arrays must have the same shape.  If not, then the library will throw an error\n\nExamples\n========\nHere are a few recipes showing how to use cwise to implement some common operations to get you started:\n\n### Multiply an array with a scalar\n```javascript\nvar muls = cwise({\n  args: [\"array\", \"scalar\"],\n  body: function(a, s) {\n    a *= s\n  }\n})\n\n//Example usage:\nmuls(array, 2.0)\n```\n\n### Initialize an array with a grid with the first index\n```javascript\nvar mgrid = cwise({\n  args: [\"index\", \"array\"],\n  body: function(i, a) {\n    a = i[0]\n  }\n})\n\n//Example usage:\nvar X = mgrid(ndarray(new Float32Array(128)))\n```\n\n### Check if any element is set\n```javascript\nvar any = cwise({\n  args: [\"array\"],\n  body: function(a) {\n    if(a) {\n      return true\n    }\n  },\n  post: function() {\n    return false\n  }\n})\n\n//Usage\nif(any(array)) {\n  // ...\n}\n```\n\n### Apply a stencil to an array\n```javascript\nvar lap_op = cwise({\n  args: [\"array\", \"array\", \"array\", \"array\", \"array\", \"array\"],\n  body: function(a, c, n, s, e, w) {\n    a = 0.25 * (n + s + e + w) - c\n  }\n})\n\nfunction laplacian(dest, src) {\n  lap_op(dest.hi(dest.shape[0]-1,dest.shape[1]-1).lo(1,1)\n      , src.hi(src.shape[0]-1,src.shape[0]-1).lo(1,1)\n      , src.hi(src.shape[0]-1,src.shape[0]).lo(1,0)\n      , src.hi(src.shape[0]-1,src.shape[0]-2).lo(1,2)\n      , src.hi(src.shape[0]-2,src.shape[0]-1).lo(0,1)\n      , src.hi(src.shape[0],src.shape[0]-1).lo(2,1))\n}\n\n//Usage:\nlaplacian(next, prev)\n```\n\n### Compute the sum of all the elements in an array\n```javascript\nvar sum = cwise({\n  args: [\"array\"],\n  pre: function() {\n    this.sum = 0\n  },\n  body: function(a) {\n    this.sum += a\n  },\n  post: function() {\n    return this.sum\n  }\n})\n  \n//Usage:\ns = sum(array)\n```\nNote that variables stored in `this` are common to all the blocks\n\n\n### Compute the index of the maximum element of an array:\n```javascript\nvar argmin = cwise({\n  args: [\"index\", \"array\"],\n  pre: function(index) {\n    this.min_v = Number.POSITIVE_INFINITY\n    this.min_index = index.slice(0)\n  },\n  body: function(index, a) {\n    if(a < this.min_v) {\n      this.min_v = a\n      for(var i=0; i<index.length; ++i) {\n        this.min_index[i] = index[i]\n      }\n    }\n  },\n  post: function() {\n    return this.min_index\n  }\n})\n\n//Usage:\nargmin(X)\n```\n\nFAQ\n===\n\nIs it fast?\n-----------\n[Yes](https://github.com/mikolalysenko/ndarray-experiments)\n\nHow does it work?\n-----------------\nYou can think of cwise as a type of macro language on top of JavaScript.  Internally, cwise uses node-falafel to parse the functions you give it and sanitize their arguments.  At run time, code for each array operation is generated lazily depending on the ordering and stride of the input arrays so that you get optimal cache performance.  These compiled functions are then memoized for future calls to the same function.  As a result, you should reuse array operations as much as possible to avoid wasting time and memory regenerating common functions.\n\nCredits\n=======\n(c) 2013 Mikola Lysenko. MIT License\n",
  "bugs": {
    "url": "https://github.com/mikolalysenko/cwise/issues"
  },
  "homepage": "https://github.com/mikolalysenko/cwise",
  "_id": "cwise@0.3.4",
  "_from": "cwise@~0.3.2"
}
