{
  "name": "glslify-stream",
  "version": "0.0.1",
  "description": "create a readable stream of glsl ast nodes that produce a module system",
  "main": "index.js",
  "dependencies": {
    "cssauron": "~0.0.2",
    "cssauron-glsl": "~0.0.0",
    "glsl-parser": "~0.0.4",
    "glsl-tokenizer": "~0.0.8",
    "shortest": "~0.0.0",
    "through": "~1.1.2"
  },
  "devDependencies": {},
  "scripts": {
    "test": "node test/index.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/glslify-stream.git"
  },
  "keywords": [
    "glslify",
    "glsl",
    "module",
    "system",
    "stream"
  ],
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "license": "MIT",
  "readme": "# glslify-stream\n\ngiven a file path, create a readable stream of [glsl-parser](https://github.com/chrisdickinson/glsl-parser) AST nodes that represent the complete dependency tree of a glsl program.\n\n```javascript\n// usage: node test.js main.glsl > output.glsl\nvar glslify = require('./index')\n  , deparser = require('glsl-deparser')\n\nvar file = require('path').resolve(process.argv[process.argv.length - 1])\n\nglslify(file)\n  .pipe(deparser())\n  .pipe(process.stdout)\n```\n\n```c\n// main.glsl\nprecision highp float;\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#pragma glslify: program_one = require(./file1, time=time, mouse=mouse, resolution=resolution)\n#pragma glslify: program_two = require(./file2, time=time, mouse=mouse, resolution=resolution)\n\nint modulo(float x, float y) {\n  return int(x - y * floor(x / y));\n}\n\nvoid main(void) {\n  ivec2 m = ivec2(modulo(gl_FragCoord.x, 2.), modulo(gl_FragCoord.y, 2.));\n\n  if(m.x == 0 || m.y == 0) {\n    program_one();\n  } else { \n    program_two();\n  }\n}\n```\n\n```c\n// file1.glsl\nvoid main(void) {\n  gl_FragColor = vec4(1., 0., 0., 1.);\n}\n\n#pragma glslify: export(main)\n```\n\n```c\n// file2.glsl\nvoid main(void) {\n  gl_FragColor = vec4(0., 0., 1., 1.);\n}\n\n#pragma glslify: export(main)\n```\n\n# GLSL API\n\nGLSLify works by mangling top-level identities in non-root modules.\n\nExported variables will be aliased on requirement.\n\n### \\#pragma glslify: VARIABLE = require(MODULE[, NAME=EXPR])\n\nImport a module and assign it the name `VARIABLE` in the local program.\n\n`MODULE` may be located within `node_modules/` or relative to the current file.\n\n**Quotes are not allowed.**\n\nIf the target module defines `attribute`, `varying`, or `uniform` global variables,\nyou may map those to a local definition or expression:\n\n```c\n\nattribute vec4 position;\n#pragma glslify: x = require(./takes_vec2, module_variable=position.xy)\n\n```\n\nIf a mapping is not defined, those requirements are forwarded on to the module requiring\nthe current module -- if no mappings are found for a definition, an error is raised.\n\n### \\#pragma glslify: export(NAME)\n\nExports a local name from the current module. If the current module is the root, this is\na no-op. There may be only one exported `NAME` per module. The `NAME` may represent a\ntype, function, or variable.\n\n# JS API\n\n### glslify(path_to_file) -> readable stream\n\nReturn a readable stream of AST nodes representing the complete program.\n\n# License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chrisdickinson/glslify-stream/issues"
  },
  "homepage": "https://github.com/chrisdickinson/glslify-stream",
  "_id": "glslify-stream@0.0.1",
  "_from": "glslify-stream@0.0.1"
}
